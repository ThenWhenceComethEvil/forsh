# vim: ft=sh: tw=80
#===============================================================================
#                                   THINKIES
#-------------------------------------------------------------------------------





MEMORY is an array.

Native BASH words are defined as:
   idx   +0       function name
   idx   +1       flag

Example:

MEMORY = [
   code_DUP       <-- function name
   1              <-- flag
]


FORTH words are defined as:
   idx   +0       "interpreter function"
   idx   +1       flag
   idx   +N       definition address(s)
   idx   +N       definition address(s)
   idx   +N       definition address(s)
   idx   +N       definition address(s)

Example:

: DOUBLE DUP + ;

# (ignore flags for now)

MEMORY = [        # idx,   what is
   code_PLUS      #
   code_DUP       #
   DOCOL          # DOUBLE
   1              #
   0              #
   6              #
   DOCOL          # DOUBLE
   1              #
   0              #
   6              #
   code_EXIT      #
]



CACHE = {
   'PLUS'   : 0
   'DUP'    : 1
   'DOUBLE' : 5
}


IP

RS { 3 3 }



SP   = 4
ADDR = MEMORY[SP]
MEMORY[ADDR]

MEMORY[MEMORY[SP]]
MEMORY[SP]


The return stack (RS) is an array of pointers to places in MEMORY.
The top of the RS is effectively the intruction pointer.


Each FORTH function ends with a function NEXT,
Which...

   1. Increments the IP
   2. Calls the function at the address of MEMORY[IP]

Each BASH function ends with an EXIT,
Which...

   1. Pops the top of the RS
   2. Calls NEXT


How it would look...
Interpreter sees the word `DOUBLE`, and runs the interpreter function at its
address in memory (DOCOL @ MEMORY[1]).

RS { 1 }


DOCOL does...

   1. Increments IP to the first word of its definition
   2. Pushes index of self to RS
   3. Calls NEXT

RS { 2  2 }


Since the return stack is holding addresses of addresses.... NEXT now has to
call
      MEMORY[ MEMORY[ RS[-1] ]]

      Or
      MEMORY[ MEMORY[ 3 ]]

      Or
      MEMORY[ 1 ]

      Or
      code_DUP


I kinda hate this.

Also weird, because return stack now can't hold addresses of things to execute.
Has to hold addrs of addrs of things to execute.

And... Means there's a special case in the interpreter.

When intr sees the word `DOUBLE`, it looks it up in dict and finds the address
is 3.

For consistency and maximum elegance, I'd like FIND to push 3 to the RS and call
NEXT. But hat doesn't work, because I'd need an addr of addr.

Double indirection sometimes, not always. Always needs a special case.
