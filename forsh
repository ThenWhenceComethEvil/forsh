#!/bin/bash
#
# FORTH in bash ... why do I do these things to myself.
#
#===============================================================================
#                                   globals
#-------------------------------------------------------------------------------
declare -gA CACHE=()       # { word -> index }
declare -gA RCACHE=()      # { index -> word } Useful when debugging to print
                           #                    the name occuring at an index.

declare -g  BUFFER=''      # Where the text of WORD is read into
declare -g  _LINE=''       # String from `read` before split into chars
declare -ga KEY_BUFFER=()  # Array of single characters from user input
declare -gi KEY_INDEX=0    # Position in the KEY_BUFFER

declare -ga M=()           # Word dictionary.
declare -ga S=()           # Parameter stack. Values.
declare -ga CS=()          # Call stack, points to MEMORY locations
declare -gi SP=            # Stack pointer

#                                  constants
#-------------------------------------------------------------------------------
                           # Index of the word's...
declare -gi _INTR=0        #  interpreter function
#declare -gi _FLAG=1       #  flag(s)
declare -gi _DEFS=1        #  beginning of definition word(s)

                           # Flag constants
declare -gi _IMMD=1        #  immediate
declare -gi _HIDE=2        #  hidden from `FIND`

#                                  debugging
#-------------------------------------------------------------------------------
function debug_stack {
   printf 'S={\n'
   for s in "${S[@]}" ; do
      printf '   %3q\n'  "$s"
   done
   printf '}\n\n'
}


function debug_cstack {
   tput bold
   printf 'CS'
   tput sgr0

   tput setaf 4
   printf '%10s   %s%25s\n'  'addr'  'value'  'dict word'
   tput sgr0

   len=$(( ${#CS[@]} - 1 ))
   for (( i=len; i>=0; --i )) ; do
      _i="${CS[i]}"
      printf '%8s%4d   %-21s%s\n'  ''  "$_i"  "${M[_i]}"  "${RCACHE[${M[_i]}]}"
   done

   printf '\n'
}


function debug_memory {
   tput bold
   printf 'MEMORY  '
   tput sgr0

   tput setaf 4
   printf '%4s %7s %24s\n'  'idx'  'value'  'dict word'
   tput sgr0

   for idx in "${!M[@]}" ; do
      value="${M[idx]}"
      word="${RCACHE[$idx]}"
      printf '%8s%4d.  %-20s %s\n'  ''  "$idx"  "$value"  "$word"
   done

   printf '\n'
}

#
#-------------------------------------------------------------------------------
# @arg   $1    :str     Word name
# @arg   $2    :str     Interpreter function name
# @arg   $3    :int     Flag
function def_code {
   HEAD=${#M[@]}
   M+=( "$2" )
   CACHE["$1"]="$HEAD"
   RCACHE["$HEAD"]="$1"
}


function def_word {
   HEAD=${#M[@]}
   CACHE["$1"]="$HEAD"
   RCACHE["$HEAD"]="$1"

   shift
   M+=( 'DOCOL'  "$@" )
}


function EXIT {
   unset 'CS[-1]'
   NEXT
}


function DOCOL {
   CS+=( $((SP += _DEFS)) )
   NEXT
}


function NEXT {
   ${M[ SP=M[CS[-1]++] ]}
}

#                              native bash words
#-------------------------------------------------------------------------------
function code_BYE { exit 0 ;}
def_code  BYE  code_BYE


# KEY()
# @description
#  Reads 1 character of stdin. Pushes the character to the stack. For
#  ergonomics, some silliness:
#
#  First reads a full line from stdin into temp var ${_LINE}. Next reads from
#  this string to split into individual characters, pushes to KEY_BUFFER[].
#
#  `KEY` returns each successive char from KEY_BUFFER[], until exhausted, then
#  reads another line.
#
function code_KEY {
   if (( KEY_INDEX == ${#KEY_BUFFER[@]} )) ; then
      KEY_BUFFER=() ; KEY_INDEX=0

      # TODO: I don't love this as a solution. Trying to:
      #        * read line from user input
      #        * not process until hitting <CR>
      #        * allow for readline editing, navigating, etc
      #
      #       This is at 90%. Still some oddness.
      #
      read -er _LINE || exit 0
      while read -N1 -r _char ; do
         KEY_BUFFER+=( "$_char" )
      done <<< "$_LINE"
   fi

   S+=( "${KEY_BUFFER[KEY_INDEX++]}" )
   if [[ ! $1 ]] ; then
      NEXT
   fi
}
def_code  KEY  code_KEY


# WORD()
# @description
#  Calls `KEY` until building a sequence of non-spece characters.
#  
function code_WORD {
   BUFFER=''

   while :; do
      code_KEY 'no_next'
      if [[ ! "${S[-1]}" =~ [[:space:]] ]] ; then
         break
      else
         unset 'S[-1]'
      fi
   done

   while :; do
      if [[ ! "${S[-1]}" =~ [[:space:]] ]] ; then
         BUFFER+="${S[-1]}"
         unset 'S[-1]'
      else
         break
      fi
      code_KEY 'no_next'
   done
   unset 'S[-1]'  #<-- whitespace after word

   S+=( "$BUFFER" )
   [[ $1 ]] || NEXT
}
def_code  WORD  code_WORD


function code_NUMBER {
   if [[ "$BUFFER" =~ (\-?[[:digit:]]+[[:digit:]_]*) ]] ; then
      S+=( "${BUFFER//_}"  1 )
   else
      S+=( "${BUFFER}"  0 )
   fi

   if [[ ! $1 ]] ; then
      NEXT
   fi
}
def_code  NUMBER  code_NUMBER


function code_FIND {
   _addr="${CACHE[${S[-1]}]}" 
   unset 'S[-1]'

   S+=( "${_addr:- -1}" )
   if [[ ! $1 ]] ; then
      NEXT
   fi
}
def_code  FIND  code_FIND


function code_BRANCH {
   (( CS[-1] += M[CS[-1]] ))
   NEXT
}
def_code  BRANCH  code_BRANCH


function code_INTERPRET {
   code_WORD 'no_next'
   code_FIND 'no_next' 

   if (( S[-1] == -1 )) ; then
      echo "no: $BUFFER"
      exit 1
   fi

   IP=${S[-1]}
   unset 'S[-1]'
   ${M[IP]}
}
def_code  INTERPRET  code_INTERPRET


word_QUIT=(
   QUIT
   ${CACHE[INTERPRET]}
   ${CACHE[BRANCH]} -2
)
def_word "${word_QUIT[@]}"
# This needs to be called after the `def_code` for INTERPRET & BRANCH, or they
# won't exist in the CACHE yet. I'm vaguely concerned about circular
# dependencies, but we'll see if that happens.

#                                    engage
#-------------------------------------------------------------------------------
debug_memory

SP=${CACHE[QUIT]}
${M[SP]}
