#!/bin/bash
#
# FORTH in bash ... why do I do these things to myself.
#
#===============================================================================
#                                   globals
#-------------------------------------------------------------------------------
declare -gA CACHE=()       # { word -> index }
declare -gA RCACHE=()      # { index -> word } Useful when debugging to print
                           #                    the name occuring at an index.

declare -g  BUFFER=''      # Where the text of WORD is read into
declare -g  _LINE=''       # String from `read` before split into chars
declare -ga KEY_BUFFER=()  # Array of single characters from user input
declare -gi KEY_INDEX=0    # Position in the KEY_BUFFER

declare -ga M=()           # Word dictionary.
declare -ga S=()           # Parameter stack. Values.
declare -ga CS=()          # Call stack, points to MEMORY locations
declare -gi SP=            # Stack pointer

#                                  constants
#-------------------------------------------------------------------------------
                           # Index of the word's...
declare -gi _INTR=0        #  interpreter function
#declare -gi _FLAG=1       #  flag(s)
declare -gi _DEFS=1        #  beginning of definition word(s)

                           # Flag constants
declare -gi _IMMD=1        #  immediate
declare -gi _HIDE=2        #  hidden from `FIND`

#                                  debugging
#-------------------------------------------------------------------------------
function debug_stack {
   printf 'S={\n'
   for s in "${S[@]}" ; do
      printf '   %3q\n'  "$s"
   done
   printf '}\n\n'
}


function debug_cstack {
   tput bold
   printf 'CS'
   tput sgr0

   tput setaf 4
   printf '%10s   %s%25s\n'  'addr'  'value'  'dict word'
   tput sgr0

   len=$(( ${#CS[@]} - 1 ))
   for (( i=len; i>=0; --i )) ; do
      _i="${CS[i]}"
      printf '%8s%4d   %-21s%s\n'  ''  "$_i"  "${M[_i]}"  "${RCACHE[${M[_i]}]}"
   done

   printf '\n'
}


function debug_memory {
   tput bold
   printf 'MEMORY  '
   tput sgr0

   tput setaf 4
   printf '%4s %7s %24s\n'  'idx'  'value'  'dict word'
   tput sgr0

   for idx in "${!M[@]}" ; do
      value="${M[idx]}"
      word="${RCACHE[$idx]}"
      printf '%8s%4d.  %-20s %s\n'  ''  "$idx"  "$value"  "$word"
   done

   printf '\n'
}

#
#-------------------------------------------------------------------------------
# @arg   $1    :str     Word name
# @arg   $2    :str     Interpreter function name
# @arg   $3    :int     Flag
function def_code {
   HEAD=${#M[@]}
   M+=( "$2" )
   CACHE["$1"]="$HEAD"
   RCACHE["$HEAD"]="$1"
}


function def_word {
   HEAD=${#M[@]}
   CACHE["$1"]="$HEAD"
   RCACHE["$HEAD"]="$1"

   shift
   M+=( 'DOCOL'  "$@" )
}


function EXIT {
   unset 'CS[-1]'
   NEXT
}


function DOCOL {
   CS+=( $((SP += _DEFS)) )
   NEXT
}


function NEXT {
   ${M[ SP=M[CS[-1]++] ]}
}


#                               forth primitives
#-------------------------------------------------------------------------------
function code_DROP {
   unset 'S[-1]'
   NEXT
}
def_code  DROP  code_DROP


function code_SWAP {
   S+=( "${S[-2]}" )
   unset 'S[-3]'
   NEXT
}
def_code  SWAP  code_SWAP


function code_DUP {
   S+=( "${S[-1]}" )
   NEXT
}
def_code  DUP  code_DUP


function code_OVER {
   S+=( "${S[-2]}" )
   NEXT
}
def_code  OVER  code_OVER


function code_ROT {
   _a="${S[-1]}"
   _b="${S[-2]}"
   _c="${S[-3]}"
   unset 'S[-1]' 'S[-2]' 'S[-3]'
   S+=( "$_c"  "$_a"  "$_b" )
   NEXT
}
def_code  ROT  code_ROT


function code_NROT {
   _a="${S[-1]}"
   _b="${S[-2]}"
   _c="${S[-3]}"
   unset 'S[-1]' 'S[-2]' 'S[-3]'
   S+=( "$_b"  "$_c"  "$_a" )
   NEXT
}
def_code  '-ROT'  code_NROT


function code_2DROP {
   unset 'S[-2]' 'S[-1]'
   NEXT
}
def_code  2DROP  code_2DROP


function code_2DUP {
   S+=( "${S[-2]}"  "${S[-1]}" )
   NEXT
}
def_code  2DUP  code_2DUP


function code_2SWAP {
   S+=( "${S[-4]}"  "${S[-3]}" )
   unset 'S[-6]' 'S[-5]'
   NEXT
}
def_code  2SWAP  code_2SWAP


function code_?DUP {
   if (( S[-1] )) ; then
      S+=( "${S[-1]}" )
   fi
   NEXT
}
def_code  ?DUP  code_?DUP


function code_INCR {
   (( ++S[-1] ))
   NEXT
}
def_code  '++'  code_INCR


function code_DECR {
   (( --S[-1] ))
   NEXT
}
def_code  '--'  code_DECR


function code_ADD {
   (( S[-2] += S[-1] ))
   unset 'S[-1]'
   NEXT
}
def_code  '+'  code_ADD


function code_SUB {
   (( S[-2] -= S[-1] ))
   unset 'S[-1]'
   NEXT
}
def_code  '-'  code_SUB


function code_MUL {
   (( S[-2] *= S[-1] ))
   unset 'S[-1]'
   NEXT
}
def_code  '*'  code_MUL


function code_DIV {
   (( S[-2] /= S[-1] ))
   unset 'S[-1]'
   NEXT
}
def_code  '/'  code_DIV


function code_EQ {
   (( S[-2] = (S[-2] == S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '='  code_EQ


function code_NE {
   (( S[-2] = (S[-2] != S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '!='  code_NE


function code_LT {
   (( S[-2] = (S[-2] < S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '<'  code_LT


function code_GT {
   (( S[-2] = (S[-2] > S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '>'  code_L


function code_LE {
   (( S[-2] = (S[-2] <= S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '<='  code_L


function code_GE {
   (( S[-2] = (S[-2] >= S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '>='  code_L


function code_ZEQ {
   (( S[-1] = (S[-1] == 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0='  code_ZEQ


function code_ZNE {
   (( S[-1] = (S[-1] != 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0!'  code_ZNE


function code_ZLT {
   (( S[-1] = (S[-1] < 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0<'  code_ZLT


function code_ZGT {
   (( S[-1] = (S[-1] > 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0>'  code_ZL


function code_ZLE {
   (( S[-1] = (S[-1] <= 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0<='  code_ZL


function code_ZGE {
   (( S[-1] = (S[-1] >= 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0>='  code_ZL


function code_AND {
   (( S[-1] &= S[-2] ))
   unset 'S[-1]'
   NEXT
}
def_code  AND  code_AND


function code_OR {
   (( S[-1] |= S[-2] ))
   unset 'S[-1]'
   NEXT
}
def_code  OR  code_OR


function code_XOR {
   (( S[-1] ^= S[-2] ))
   unset 'S[-1]'
   NEXT
}
def_code  XOR  code_XOR


function code_NOT {
   (( S[-1] = !S[-1] ))
   NEXT
}
def_code  NOT  code_NOT

#
#-------------------------------------------------------------------------------
function code_BYE { exit 0 ;}
def_code  BYE  code_BYE


# KEY()
# @description
#  Reads 1 character of stdin. Pushes the character to the stack. For
#  ergonomics, some silliness:
#
#  First reads a full line from stdin into temp var ${_LINE}. Next reads from
#  this string to split into individual characters, pushes to KEY_BUFFER[].
#
#  `KEY` returns each successive char from KEY_BUFFER[], until exhausted, then
#  reads another line.
#
function code_KEY {
   if (( KEY_INDEX == ${#KEY_BUFFER[@]} )) ; then
      KEY_BUFFER=() ; KEY_INDEX=0

      # TODO: I don't love this as a solution. Trying to:
      #        * read line from user input
      #        * not process until hitting <CR>
      #        * allow for readline editing, navigating, etc
      #
      #       This is at 90%. Still some oddness.
      #
      read -er _LINE || exit 0
      while read -N1 -r _char ; do
         KEY_BUFFER+=( "$_char" )
      done <<< "$_LINE"
   fi

   S+=( "${KEY_BUFFER[KEY_INDEX++]}" )
   if [[ ! $1 ]] ; then
      NEXT
   fi
}
def_code  KEY  code_KEY


# WORD()
# @description
#  Calls `KEY` until building a sequence of non-spece characters.
#  
function code_WORD {
   BUFFER=''

   while :; do
      code_KEY 'no_next'
      if [[ ! "${S[-1]}" =~ [[:space:]] ]] ; then
         break
      else
         unset 'S[-1]'
      fi
   done

   while :; do
      if [[ ! "${S[-1]}" =~ [[:space:]] ]] ; then
         BUFFER+="${S[-1]}"
         unset 'S[-1]'
      else
         break
      fi
      code_KEY 'no_next'
   done
   unset 'S[-1]'  #<-- whitespace after word

   S+=( "$BUFFER" )
   [[ $1 ]] || NEXT
}
def_code  WORD  code_WORD


#function code_NUMBER {
#   if [[ "$BUFFER" =~ (\-?[[:digit:]]+[[:digit:]_]*) ]] ; then
#      S+=( "${BUFFER//_}"  1 )
#   else
#      S+=( "${BUFFER}"  0 )
#   fi
#
#   if [[ ! $1 ]] ; then
#      NEXT
#   fi
#}
#def_code  NUMBER  code_NUMBER


#function code_CALL {
#   SP=${S[-1]}
#   unset 'S[-1]'
#   ${M[SP]}
#}


function code_FIND {
   _addr="${CACHE[${S[-1]}]}" 
   unset 'S[-1]'

   S+=( "${_addr:- -1}" )
   if [[ ! $1 ]] ; then
      NEXT
   fi
}
def_code  FIND  code_FIND


function code_BRANCH {
   (( CS[-1] += M[CS[-1]] ))
   NEXT
}
def_code  BRANCH  code_BRANCH


function code_INTERPRET {
   code_WORD 'no_next'
   code_FIND 'no_next' 

   if (( S[-1] == -1 )) ; then
      echo "no: $BUFFER"
      exit 1
   fi

   SP=${S[-1]}
   unset 'S[-1]'
   ${M[SP]}
}
def_code  INTERPRET  code_INTERPRET


word_QUIT=(
   QUIT
   ${CACHE[INTERPRET]}
   ${CACHE[BRANCH]} -2
)
def_word "${word_QUIT[@]}"
# This needs to be called after the `def_code` for INTERPRET & BRANCH, or they
# won't exist in the CACHE yet. I'm vaguely concerned about circular
# dependencies, but we'll see if that happens.

#                                    engage
#-------------------------------------------------------------------------------
debug_memory

SP=${CACHE[QUIT]}
${M[SP]}
