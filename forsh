#!/bin/bash
#-------------------------------------------------------------------------------
# FORTH in bash ... why do I do these things to myself.
#-------------------------------------------------------------------------------
# Can't `set -e` here, as so many of the arithmetic tests return 0.

#===============================================================================
#                                   globals
#-------------------------------------------------------------------------------
declare -gA  CACHE=()         # { word  -> index }
declare -gA  RCACHE=()        # { index -> word  } Useful when debugging to print
                              #                    the name occurring at an index
declare -gA  PREV_DEFS=()     # { index -> index } word's index to the index of
                              #                    its past definition.

declare -g   _LINE=''         # String from `read` before split into chars
declare -g   BUFFER=''        # Where the text of WORD is read into
declare -gi  KEY_INDEX=0      # Position in the KEY_BUFFER
declare -ga  KEY_BUFFER=()    # Array of single characters from user input

declare -ga  S=()             # Parameter stack. Values.
declare -ga  CS=()            # Call stack, points to MEMORY locations
declare -gi  SP=              # Stack pointer
declare -ga  M=( :: )         # Word dictionary. Index of 0 should indicate a
                              # word was unfound. `::` is an invalid command,
                              # and won't do catastrophic shit if executed
                              # accidentally.

#                                  constants
#-------------------------------------------------------------------------------
# Word offsets.
declare -gi  FLAG_OFFSET=1    # Flag offset
declare -gi  DEFS_OFFSET=2    # Beginning of definition word(s)

# Flag constants
declare -gi  IMMD_FLAG=1      # Immediate
declare -gi  HIDE_FLAG=2      # Hidden from `FIND`

# State flags
declare -gi  STATE=0
declare -gi  EXECUTE_STATE=0
declare -gi  COMPILE_STATE=1

#                                  debugging
#-------------------------------------------------------------------------------
function debug_stack {
   printf 'STACK {\n'
   for s in "${S[@]}" ; do
      printf '   %3q\n'  "$s"
   done
   printf '}\n\n'
}


function debug_call_stack {
   tput bold
   printf 'CS'
   tput sgr0

   tput setaf 4
   printf '%10s   %s%25s\n'  'addr'  'value'  'dict word'
   tput sgr0

   for (( i=${#CS[@]}-1 ; i>=0 ; --i )) ; do
      _i="${CS[i]}"
      printf '%8s%4d   %-21s%s\n'  ''  "$_i"  "${M[_i]}"  "${RCACHE[${M[_i]}]}"
   done

   printf '\n'
}


function debug_memory {
   tput bold
   printf 'MEMORY  '
   tput sgr0

   tput setaf 4
   printf '%4s %7s %24s\n'  'idx'  'value'  'dict word'
   tput sgr0

   for idx in "${!M[@]}" ; do
      value="${M[idx]}"
      word="${RCACHE[$idx]}"
      printf '%8s%4d.  %-20s %s\n'  ''  "$idx"  "$value"  "$word"
   done

   printf '\n'
}


function debug_cache {
   printf 'CACHE {\n'
   {  for i in "${!CACHE[@]}" ; do
         printf '   %4d  <-  %s\n'  "${CACHE[$i]}"  "$i"
      done
   } | sort -n
   printf '}\n\n'
}

#
#-------------------------------------------------------------------------------
# @arg   $1    :str     Word name
# @arg   $2    :str     Interpreter function name
# @arg   $3    :int     Flag
function def_code {
   LATEST=${#M[@]}
   M+=( "$2"  "${3:-0}" )

   # Tracks previous definitions for the same word. If the word 'DOUBLE' is
   # already defined at M[10], and now at M[20], PREV_DEFS looks like:
   # { 20 -> 10,  10 -> '' }.
   # 
   # Allows for searching past definitions when a later one is marked as HIDDEN.
   # Follow the links back to
   #  (1)   an empty string
   #  (2)   a non-hidden word
   #
   PREV_DEFS["$LATEST"]="${CACHE[$1]}"

   CACHE[$1]="$LATEST"
   RCACHE["$LATEST"]="$1"
}


function def_word {
   local name="$1"
   local -i flag="${2:-0}"
   shift ; shift

   LATEST=${#M[@]}
   CACHE["$name"]="$LATEST"
   RCACHE["$LATEST"]="$name"

   M+=( 'DOCOL'  "$flag"  "$@" )
}


function NEXT {
   ${M[ SP=M[CS[-1]++] ]}
}


function DOCOL {
   CS+=( $((SP += DEFS_OFFSET)) )
   NEXT
}


function code_EXIT {
   unset 'CS[-1]'
   NEXT
}
def_code  EXIT  code_EXIT


#                               forth primitives
#-------------------------------------------------------------------------------
function code_BYE { exit 0 ;}
def_code  BYE  code_BYE


function code_DROP {
   unset 'S[-1]'
   NEXT
}
def_code  DROP  code_DROP


function code_SWAP {
   S+=( "${S[-2]}" )
   unset 'S[-3]'
   NEXT
}
def_code  SWAP  code_SWAP


function code_DUP {
   S+=( "${S[-1]}" )
   NEXT
}
def_code  DUP  code_DUP


function code_OVER {
   S+=( "${S[-2]}" )
   NEXT
}
def_code  OVER  code_OVER


function code_ROT {
   _a="${S[-1]}"
   _b="${S[-2]}"
   _c="${S[-3]}"
   unset 'S[-1]' 'S[-2]' 'S[-3]'
   S+=( "$_c"  "$_a"  "$_b" )
   NEXT
}
def_code  ROT  code_ROT


function code_NROT {
   _a="${S[-1]}"
   _b="${S[-2]}"
   _c="${S[-3]}"
   unset 'S[-3]' 'S[-2]' 'S[-1]'
   S+=( "$_b"  "$_c"  "$_a" )
   NEXT
}
def_code  '-ROT'  code_NROT


function code_2DROP {
   unset 'S[-2]' 'S[-1]'
   NEXT
}
def_code  2DROP  code_2DROP


function code_2DUP {
   S+=( "${S[-2]}"  "${S[-1]}" )
   NEXT
}
def_code  2DUP  code_2DUP


function code_2SWAP {
   S+=( "${S[-4]}"  "${S[-3]}" )
   unset 'S[-6]' 'S[-5]'
   NEXT
}
def_code  2SWAP  code_2SWAP


function code_?DUP {
   if (( S[-1] )) ; then
      S+=( "${S[-1]}" )
   fi
   NEXT
}
def_code  ?DUP  code_?DUP


function code_INCR {
   (( ++S[-1] ))
   NEXT
}
def_code  '++'  code_INCR


function code_DECR {
   (( --S[-1] ))
   NEXT
}
def_code  '--'  code_DECR


function code_ADD {
   (( S[-2] += S[-1] ))
   unset 'S[-1]'
   NEXT
}
def_code  '+'  code_ADD


function code_SUB {
   (( S[-2] -= S[-1] ))
   unset 'S[-1]'
   NEXT
}
def_code  '-'  code_SUB


function code_MUL {
   (( S[-2] *= S[-1] ))
   unset 'S[-1]'
   NEXT
}
def_code  '*'  code_MUL


function code_DIV {
   (( S[-2] /= S[-1] ))
   unset 'S[-1]'
   NEXT
}
def_code  '/'  code_DIV


function code_EQ {
   (( S[-2] = (S[-2] == S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '='  code_EQ


function code_NE {
   (( S[-2] = (S[-2] != S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '!='  code_NE


function code_LT {
   (( S[-2] = (S[-2] < S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '<'  code_LT


function code_GT {
   (( S[-2] = (S[-2] > S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '>'  code_L


function code_LE {
   (( S[-2] = (S[-2] <= S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '<='  code_L


function code_GE {
   (( S[-2] = (S[-2] >= S[-1]) ))
   unset 'S[-1]'
   NEXT
}
def_code  '>='  code_L


function code_ZEQ {
   (( S[-1] = (S[-1] == 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0='  code_ZEQ


function code_ZNE {
   (( S[-1] = (S[-1] != 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0!'  code_ZNE


function code_ZLT {
   (( S[-1] = (S[-1] < 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0<'  code_ZLT


function code_ZGT {
   (( S[-1] = (S[-1] > 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0>'  code_ZL


function code_ZLE {
   (( S[-1] = (S[-1] <= 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0<='  code_ZL


function code_ZGE {
   (( S[-1] = (S[-1] >= 0) ))
   unset 'S[-1]'
   NEXT
}
def_code  '0>='  code_ZL


function code_AND {
   (( S[-1] &= S[-2] ))
   unset 'S[-1]'
   NEXT
}
def_code  AND  code_AND


function code_OR {
   (( S[-1] |= S[-2] ))
   unset 'S[-1]'
   NEXT
}
def_code  OR  code_OR


function code_XOR {
   (( S[-1] ^= S[-2] ))
   unset 'S[-1]'
   NEXT
}
def_code  XOR  code_XOR


function code_NOT {
   (( S[-1] = !S[-1] ))
   NEXT
}
def_code  NOT  code_NOT

#                              memory management
#-------------------------------------------------------------------------------
# I don't know if these are necessary yet. May want to change these into
# modifying a global VARIABLES{} assoc. array.
function code_STORE {
   (( M[S[-1]] = M[S[-2]] ))
   unset 'S[-2]' 'S[-1]'
   NEXT
}
def_code  '!'  code_STORE


function code_FETCH {
   S+=( "${M[S[-1]]}" )
   unset 'S[-1]'
   NEXT
}
def_code  '@'  code_FETCH


function code_ADDSTORE {
   (( M[S[-1]] += S[-2] ))
   unset 'S[-1]' 'S[-2]'
   NEXT
}
def_code  '+!'  code_ADDSTORE


function code_SUBSTORE {
   (( M[S[-1]] += S[-2] ))
   unset 'S[-1]' 'S[-2]'
   NEXT
}
def_code  '-!'  code_SUBSTORE


# This does more in real FORTH, in which it pushes the header (link, name len,
# name, and padding to 4-byte boundry), and sets LATEST & HERE.
#
# The latter variable is unnecessary. No need to point to final index in memory.
# Can easily push to end of M[] or S[].
#
# Likewise, there is no header here. First element is the interpreter function.
#
# This...
#  1. Sets $LATEST to top of the stack
#  2. Creates CACHE entry of $1 -> $LATEST
#
function code_CREATE {
   LATEST=${#M[@]}
   CACHE["${S[-1]}"]="$LATEST"
   unset 'S[-1]'
   NEXT
}
def_code  CREATE  code_CREATE


# Unsure how this translates right now. Just pushes int to memory?
function code_COMMA {
   M+=( "${S[-1]}" )
   unset 'S[-1]'
   NEXT
}
def_code  ','  code_COMMA

#                                 return stack
#-------------------------------------------------------------------------------
function code_TOR {
   CS+=( "${S[-1]}" )
   unset 'S[-1]'
   NEXT
}
def_code  '>R'  code_TOR


function code_FROMR {
   S+=( "${CS[-1]}" )
   unset 'CS[-1]'
   NEXT
}
def_code  'R>'  code_FROMR


function code_RDROP {
   unset 'CS[-1]'
   NEXT
}
def_code  'RDROP'  code_RDROP

##                                  variables
##-------------------------------------------------------------------------------
#function code_STATE {
#   S+=( "$STATE" )
#   NEXT
#}
#def_code  'STATE'  code_STATE


function code_LATEST {
   S+=( "$LATEST" )
   NEXT
}
def_code  'LATEST'  code_LATEST

##                                  constants
##-------------------------------------------------------------------------------
#function code_IMMD {
#   S+=( "$_IMMD" )
#   NEXT
#}
#def_code  'IMMD_FLAG'  code_IMMD
#
#
#function code_HIDE {
#   S+=( "$_HIDE" )
#   NEXT
#}
#def_code  'HIDE_FLAG'  code_HIDE

#                                     I/O
#-------------------------------------------------------------------------------
function code_dot {
   printf '%s\n'  "${S[-1]}"
   unset 'S[-1]'
   NEXT
}
def_code  '.'  code_dot


function code_dot_s { debug_stack  ; NEXT ;}
def_code  '.s'  code_dot_s

function code_dot_m { debug_memory ; NEXT ;}
def_code  '.m'  code_dot_m

function code_dot_c { debug_cache  ; NEXT ;}
def_code  '.c'  code_dot_c


function code_dot_cache {
   printf '%s\n'  "${CACHE[${S[-1]}]}"
   unset 'S[-1]'
   NEXT
}
def_code  '.cache'  code_dot_cache


function code_dot_rcache {
   printf '%s\n'  "${RCACHE[${S[-1]}]}"
   unset 'S[-1]'
   NEXT
}
def_code  '.rcache'  code_dot_rcache


function code_EMIT {
   printf '%s'  "${S[-1]}"
   unset 'S[-1]'
   NEXT
}
def_code  EMIT  code_EMIT


# KEY()
# @description
#  Reads 1 character of stdin. Pushes the character to the stack. For
#  ergonomics, some silliness:
#
#  First reads a full line from stdin into temp var ${_LINE}. Next reads from
#  this string to split into individual characters, pushes to KEY_BUFFER[].
#
#  `KEY` returns each successive char from KEY_BUFFER[], until exhausted, then
#  reads another line.
#
function code_KEY {
   if (( KEY_INDEX == ${#KEY_BUFFER[@]} )) ; then
      KEY_BUFFER=() ; KEY_INDEX=0

      read -er _LINE || exit 0
      while read -N1 -r _char ; do
         KEY_BUFFER+=( "$_char" )
      done <<< "$_LINE"
   fi

   S+=( "${KEY_BUFFER[KEY_INDEX++]}" )
   if [[ ! $1 ]] ; then
      NEXT
   fi
}
def_code  KEY  code_KEY


function code_WORD {
   BUFFER=''

   while :; do
      code_KEY 'no_next'
      if [[ ! "${S[-1]}" =~ [[:space:]] ]] ; then
         break
      else
         unset 'S[-1]'
      fi
   done

   while :; do
      if [[ ! "${S[-1]}" =~ [[:space:]] ]] ; then
         BUFFER+="${S[-1]}"
         unset 'S[-1]'
      else
         break
      fi
      code_KEY 'no_next'
   done
   unset 'S[-1]'  #<-- whitespace after word

   S+=( "$BUFFER" )
   if [[ ! $1 ]] ; then
      NEXT
   fi
}
def_code  WORD  code_WORD


function code_LIT {
   S+=( "${M[CS[-1]]}" )
   NEXT
}
def_code  LIT  code_LIT


function code_NUMBER {
   if [[ "${S[-1]}" =~ ^(\-?[[:digit:]]+[[:digit:]_]*)$ ]] ; then
      unset 'S[-1]'
      S+=( "${BASH_REMATCH[1]//_}"  1 )
   else
      S+=( 0 )
   fi

   if [[ ! $1 ]] ; then
      NEXT
   fi
}
def_code  NUMBER  code_NUMBER


function code_FIND {
   _addr=${CACHE[${S[-1]}]}
   unset 'S[-1]'

   # Some trickery here. Assigning `_addr` to itself sets to `0' if unset. Don't
   # need early return above this, or explicitly setting to `0' if unfound.
   while ((
      _addr = _addr ,
      _hide = M[_addr + FLAG_OFFSET] & HIDE_FLAG
   )) ; do 
      _addr=${PREV_DEFS[$_addr]}
   done

   S+=( "$_addr" )
   if [[ ! $1 ]] ; then
      NEXT
   fi
}
def_code  FIND  code_FIND


function code_BRANCH {
   (( CS[-1] += M[CS[-1]] ))
   NEXT
}
def_code  BRANCH  code_BRANCH

#                              interpreter words
#-------------------------------------------------------------------------------
function _exe_word {
   SP=${S[-1]}
   unset 'S[-1]'
   ${M[SP]}
}

function _push_number {
   S[-1]="${_word}"
   code_NUMBER 'no_next'

   # Not a number, it's a terrible failure.
   if (( ! S[-1] )) ; then
      printf "no: ${BUFFER}\n"  1>&2
      exit 1
   fi

   unset 'S[-1]'  # pop the `true` flag
   NEXT
}
 
function code_INTERPRET {
   code_WORD 'no_next' ; local _word="${S[-1]}"
   code_FIND 'no_next' 

   if (( S[-1] )) ; then
      # It's a word.
      _exe_word "$_word"
   else
      # Not a word, it's a number?
      _push_number
   fi
}
def_code  INTERPRET  code_INTERPRET


word_QUIT=(
   ${CACHE[INTERPRET]}
   ${CACHE[BRANCH]} -2
)
def_word  'QUIT'  "${word_QUIT[@]}"
# This needs to be called after the `def_code` for INTERPRET & BRANCH, or they
# won't exist in the CACHE yet. I'm vaguely concerned about circular
# dependencies, but we'll see if that happens.


function code_RBRAC {
   (( STATE = EXECUTE_STATE ))
   NEXT
}
def_code  '['  code_RBRAC


function code_LBRAC {
   (( STATE = COMPILE_STATE ))
   NEXT
}
def_code  ']'  code_LBRAC  "$IMMD_FLAG"


word_COLON=(
   ${CACHE[WORD]}    ${CACHE[CREATE]}
   ${CACHE[LIT]}     'DOCOL'
   ${CACHE[LATEST]}  ${CACHE[HIDDEN]}
   ${CACHE[']']}
   ${CACHE[EXIT]}
)
def_word  ':'  "${word_COLON[@]}"


word_SEMI=(
   ${CACHE[LIT]}     ${CACHE[EXIT]}    ${CACHE[COMMA]}
   ${CACHE[LATEST]}  ${CACHE[HIDDEN]}
   ${CACHE[']']}
   ${CACHE[EXIT]}
)
def_word  ';'  "${word_SEMI[@]}"


# Toggle HIDDEN flag on word.
function code_HIDDEN {
   ((
      _addr = S[-1] + FLAG_OFFSET ,
      M[_addr] ^= HIDE_FLAG
   ))
   unset 'S[-1]'
   NEXT
}
def_code  HIDDEN  code_HIDDEN


word_HIDE=(
   ${CACHE[WORD]}    ${CACHE[FIND]}
   ${CACHE[HIDDEN]}
   ${CACHE[EXIT]}
)
def_word  'HIDE'  "${word_HIDE[@]}"


function code_IMMEDIATE {
   (( M[LATEST + FLAG_OFFSET] ^= IMMD_FLAG ))
   NEXT
}
def_code  'IMMEDIATE'  code_IMMEDIATE  "$IMMD_FLAG"


# This should work. HIDE works, and it's pretty much the same thing.
# ...
# Wait, HIDE doesn't work any more. I dunno what's happened.
word_TICK=(
   ${CACHE[WORD]}
   ${CACHE[FIND]}
   ${CACHE[EXIT]}
)
def_word  "'"  "${word_TICK[@]}"


#                                    engage
#-------------------------------------------------------------------------------
while (( $# )) ; do
   case "$1" in
      -x)   set -x       ;;
      -m)   debug_memory ;;
   esac
   shift
done

SP=${CACHE[QUIT]}
${M[SP]}
