#!/bin/bash
#
# FORTH in bash ... why do I do these things to myself.
#
#===============================================================================
#                                   globals
#-------------------------------------------------------------------------------
declare -gA CACHE=()       # { word -> index }
declare -gA RCACHE=()      # { index -> word } Useful when debugging to print
                           #                    the name occuring at an index.

declare -g  BUFFER=''      # Where the text of WORD is read into
declare -g  _LINE=''       # String from `read` before split into chars
declare -ga KEY_BUFFER=()  # Array of single characters from user input
declare -gi KEY_INDEX=0    # Position in the KEY_BUFFER

declare -ga S=()           # Parameter stack. Values.
declare -ga RS=()          # Return stack. Address pointers.
declare -gi IP=            # Instruction pointer
declare -ga M=( '' )       # Word dictionary. Idx starts at 1. 0 is the NULL
                           # index of an unfound word.

#                                  constants
#-------------------------------------------------------------------------------
                           # Index of the word's...
declare -gi _INTR=0        #  interpreter function
#declare -gi _FLAG=1       #  flag(s)
declare -gi _DEFS=1        #  beginning of definition word(s)

                           # Flag constants
declare -gi _IMMD=1        #  immediate
declare -gi _HIDE=2        #  hidden from `FIND`

#                                  debugging
#-------------------------------------------------------------------------------
function debug_stack {
   printf 'S={\n'
   for s in "${S[@]}" ; do
      printf '   %3q\n'  "$s"
   done
   printf '}\n\n'
}


function debug_rstack {
   tput bold
   printf 'RS'
   tput sgr0

   tput setaf 4
   printf '%10s   %s%25s\n'  'addr'  'value'  'dict word'
   tput sgr0

   len=$(( ${#RS[@]} - 1 ))
   for (( i=len; i>=0; --i )) ; do
      _i="${RS[i]}"
      printf '%8s%4d   %-21s%s\n'  ''  "$_i"  "${M[_i]}"  "${RCACHE[$_i]}"
   done

   printf '\n'
}


function debug_memory {
   tput bold
   printf 'MEMORY  '
   tput sgr0

   tput setaf 4
   printf '%4s %7s %24s\n'  'idx'  'value'  'dict word'
   tput sgr0

   for idx in "${!M[@]}" ; do
      value="${M[idx]}"
      word="${RCACHE[$idx]}"
      printf '%8s%4d.  %-20s %s\n'  ''  "$idx"  "$value"  "$word"
   done

   printf '\n'
}

#
#-------------------------------------------------------------------------------
# @arg   $1    :str     Word name
# @arg   $2    :fn      Interpreter function
# @arg   $3    :binary  Binary flag [2#001, 2#010]
function def_code {
   HEAD="${#M[@]}"
   M+=( "$2" )

   CACHE["$1"]="$HEAD"
   RCACHE["$HEAD"]="$1"
}


function def_word {
   HEAD="${#M[@]}"
   CACHE["$1"]="$HEAD"
   RCACHE["$HEAD"]="$1"

   shift
   M+=( DOCOL "$@" )
}


function EXIT {
   unset 'RS[-1]'
   NEXT
}


function DOCOL {
   # Increments the top of the return stack by the _DEFS offset.
   (( RS[-1] += _DEFS )) ; NEXT
}


function NEXT {
   # Top of RS[] contains an address in M[], which contains an address in M[].
   # Gotta double-index it.
   ${M[M[RS[-1]]]}
}

#                              native bash words
#-------------------------------------------------------------------------------
function code_BYE { exit 0 ;}
def_code  BYE  code_BYE


# KEY()
# @description
#  Reads 1 character of stdin. Pushes the character to the stack. For
#  ergonomics, some silliness:
#
#  First reads a full line from stdin into temp var ${_LINE}. Next reads from
#  this string to split into individual characters, pushes to KEY_BUFFER[].
#
#  `KEY` returns each successive char from KEY_BUFFER[], until exhausted, then
#  reads another line.
#
function code_KEY {
   if (( KEY_INDEX == ${#KEY_BUFFER[@]} )) ; then
      KEY_BUFFER=() ; KEY_INDEX=0

      # TODO: I don't love this as a solution. Trying to:
      #        * read line from user input
      #        * not process until hitting <CR>
      #        * allow for readline editing, navigating, etc
      #
      #       This is at 90%. Still some oddness.
      #
      read -er _LINE || exit 0
      while read -N1 -r _char ; do
         KEY_BUFFER+=( "$_char" )
      done <<< "$_LINE"
   fi

   S+=( "${KEY_BUFFER[KEY_INDEX++]}" )
   [[ $1 ]] || NEXT
}
def_code  KEY  code_KEY


# WORD()
# @description
#  Calls `KEY` until building a sequence of non-spece characters.
#  
function code_WORD {
   BUFFER=''

   while :; do
      code_KEY 'no_next'
      if [[ ! "${S[-1]}" =~ [[:space:]] ]] ; then
         break
      else
         unset 'S[-1]'
      fi
   done

   while :; do
      if [[ ! "${S[-1]}" =~ [[:space:]] ]] ; then
         BUFFER+="${S[-1]}"
         unset 'S[-1]'
      else
         break
      fi
      code_KEY 'no_next'
   done
   unset 'S[-1]'  #<-- whitespace after word

   [[ $1 ]] || {
      NEXT
      S+=( "$BUFFER" )
   }
}
def_code  WORD  code_WORD


function code_NUMBER {
   if [[ "$BUFFER" =~ (\-?[[:digit:]]+[[:digit:]_]*) ]] ; then
      S+=( "${BUFFER//_}"  1 )
   else
      S+=( "${BUFFER}"  0 )
   fi

   [[ $1 ]] || NEXT
}
def_code  NUMBER  code_NUMBER


function code_FIND {
   IP="${CACHE[$BUFFER]:-0}" 
   [[ $1 ]] || {
      S+=( "$IP" ) ; NEXT
   }
}
def_code  FIND  code_FIND


function code_BRANCH {
   (( RS[-1] += M[RS[-1]] ))
   NEXT
}
def_code  BRANCH  code_BRANCH


function code_INTERPRET {
   code_WORD 'no_next'
   code_FIND 'no_next' 

   if ! (( IP )) ; then
      echo "no: $BUFFER"
      exit 1
   fi

   ${M[IP]}
}
def_code  INTERPRET  code_INTERPRET


word_QUIT=(
   QUIT
   "${CACHE[INTERPRET]}"
   "${CACHE[BRANCH]}" -3
)
def_word "${word_QUIT[@]}"
# This needs to be called after the `def_code` for INTERPRET & BRANCH, or they
# won't exist in the CACHE yet. I'm vaguely concerned about circular
# dependencies, but we'll see if that happens.

#                                    engage
#-------------------------------------------------------------------------------
RS+=( ${CACHE[QUIT]} ) ; DOCOL
# Not sure how to actually start the program. I guess this is similar-ish to how
# jonesforth kicks itself off.

#debug_stack
#debug_rstack
#debug_memory
