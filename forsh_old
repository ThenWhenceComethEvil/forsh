#!/bin/bash
# FORTH in bash ... why do I do these things to myself.

#===============================================================================
#                                    NOTES
#-------------------------------------------------------------------------------
# I have a tendency to try and do things as right as possible from the get-go.
# While I believe this is, in large part (a good approach) it's not without
# problems. Example, here. I've had a difficulty actualy *starting* this idiot
# project, out of a desire to design a "proper" forth.
#
# Clearly that's not working.
#
# Below is a bad forth. Hopefully it will help me to learn enough to later
# write a good one.
#
#-------------------------------------------------------------------------------
# Dictionary structure is just a linked list. Allows the same word to be re-
# defined later, but prior references to that name keep the old definition.
#
# In the asm version, each "definition" entry points to the corresponding word's
# .codeword. No direct comparison in bash.
#
# A native bash function's codeword is easy to understand. Points to a bash
# function to run it. E.g., the "codeword" for `+` is `__forth__add` or
# whatever namescheme I want. Probably need a consistent way to name symbols.
# I think as a lower-case version of their name. E.g., the word `PLUS` is
# described as `code_PLUS`, while the word `+` would be `code_plus`. Equally,
# 'GREATER' -> `code_GREATER`, while '>' -> `code_greater`.
#
#-------------------------------------------------------------------------------
# I'm thinking again about maybe just having a single global array holding *ALL*
# of the words. More similar to the layout of the asm one actually. Words will
# then actually point to the address in the MEMORY[] array of each definition
# word's `codeword`.
#
# This is an interesting idea. I'm going to need to think about this a bit more.
# Depends how fast bash is at indexing into an array, vs declaring a bunch of
# arrays dynamically and nameref'ing to them.
#
# I started writing this as notes to Papa, but it then became very long.
#
#declare -a MEMORY=()
#declare HEAD=''
#
#function push_word {
#   # Index of what will *become* the head of the Words linked list
#   local new_head="${#MEMORY[@]}"
#
#   # Link to the prior head.
#   local old_head="$HEAD"
#
#   local name="$1" ; shift
#   MEMORY+=( "$old_head"  "$name" )
#
#   # Walks back in words list, finds the index of the interpreter for $word,
#   # and pushes to $MEMORY.
#   for word in "$@" ; do
#      if word_find "$word" ; then
#         MEMORY+=( "$WIDX" )
#      else
#         echo "Word not found: $word."
#         exit 1
#      fi
#   done
#   find_word "_EXIT"
#
#   HEAD="$new_head"
#}
#
#function word_find {
#   _offset_name=1
#   _offset_intr=2
#
#   jump="$HEAD"
#
#   while (( jump )) ; do
#      if [[ "${MEMORY[jump + _offset_name]}" == "$1" ]] ; then
#         WIDX=$(( jump + _offset_intr ))
#         return 0
#      else
#         jump="${MEMORY[jump]}"
#      fi
#   done
#
#   return 1
#}
#
## Example:
#push_word  "DOUBLE"  "DUP"  "+"
#push_word  "QUAD"  "DOUBLE"  "DUP"  "+"
#
## Memory is now:
## [ 
##   ...,
##   100, "DOUBLE", <INTR>, <DUP>, <PLUS>, <_EXIT>,
##   105, "QUAD",   <INTR>, 102,   <DUP>,  <PLUS>,  <_EXIT>
## ]
#
#-------------------------------------------------------------------------------

declare -ga CHARRAY=()
declare -gi IDX=0

declare -g  HEAD=          # head of **words** linked list
declare -g  WORD=          # current word
declare -gi INST_IDX=      # index of next instruction

declare -a  STACK=()       # values
declare -a  RSTACK=()      # return stack

declare -gi _WORD_NUM=0

declare -gi EXECUTING=1    # Expecting [0, 1]. If not executing (1), it's in
                           # compile mode

#                                  constants
#-------------------------------------------------------------------------------
                           # Index of the word's...
declare -gi _NAME=1        #  name
declare -gi _FLAG=2        #  flag(s)
declare -gi _INTR=3        #  interpreter function
declare -gi _DEFN=4        #  beginning of definition word(s)

                           # Flag constants
declare -gi _IMED=2#001    #  immediate
declare -gi _HIDE=2#010    #  hidden from `FIND`

#                                    utils
#-------------------------------------------------------------------------------
function usage {
   case "$1" in
      0)  out=/dev/stdout ;;
      *)  out=/dev/stderr ;;
   esac

   cat <<EOF > "$out"
usage:  $(basename "${BASH_SOURCE[0]}")  [OPTION]  [FILE]

options:
   -h | --help    show this message and exit
EOF

   exit "$1"
}


# This probably does not need its own function. Need to think through if it is
# needed or not. Depends how FORTH parses user input for things like strings.
function str_read {
   CHARRAY=()
   IDX=0

   while read -rN1 char ; do
      CHARRAY+=( "$char" )
   done <<< "$1"
}


# word_new()
# @description
#  [0]  ::  subsequent array in linked list
#  [1]  ::  name
#  [2]  ::  flag(s)
#  [3]  ::  codeword
#  [4:] ::  subsequent words
#
# @arg   $1    :str  Name
#
# TODO: For now only using the name, and executing everything directly in bash.
#       Can later add the FORTH interpreter..
#
function word_new {
   local d="_FORTH_WORD_$(( ++_WORD_NUM ))"
   declare -ga "$d"
   local -n d_r="$d"
   d_r=( "$HEAD"  "$1"  "$2" )
   HEAD="$d"
}


#function NEXT {
#   local -n word_r="$WORD"
#   #...
#}


#function DOCOL {
#   RSTACK+=( "$INST_IDX" "$WORD" )
#   #...
#}


#while (( $# )) ; do case "$1" in
#      -h | --help)  usage 0 ;;
#      *) file="$1" ; shift
#   esac
#done


#if [[ "$file" ]] ; then
#   str_read "$(<$file)"
#fi




#-------------------------------------------------------------------------------
# Stuff I'm more sure of goes below this point.
#-------------------------------------------------------------------------------




# code_WORD()
# @description
#  Reads characters (skipping whitespace) until a sequence of non-space
#  characters has been read into global $WORD_TEXT.
#
# @env   IDX
# @env   CHARRAY[]
#
# @set   IDX
# @set   WORD_TEXT
#
# @noargs
function code_WORD {
   WORD_TEXT=''
   
   # TODO(profiling): This function will be called a lot. Some things to ask:
   #  - Is regex faster than sequential tests
   #  - can `read -d $' '` be used, stripping out a final $'\n' if present
   #    - is it faster?
   #  - maybe indexing directly into a string, instead of first converting to
   #    an array? We're not doing any lookahead/behind, so it may work. Depends
   #    if the string slice indexing is so much slower as to make it not worth
   #    it
   while [[ ${CHARRAY[IDX]} =~ [[:space:]] ]] ; do
      (( ++IDX ))
   done

   # TODO(profiling): Gotta be a better way to take non-whitespace text than
   # this.
   while CHAR=${CHARRAY[IDX]} && [[ ! "$CHAR" =~ [[:space:]] ]] ; do
      (( ++IDX )) ; WORD_TEXT+="$CHAR"
   done
}

word_new  WORD  code_WORD


function code_NUMBER {
   if [[ "$WORD_TEXT" =~ (\-?[[:digit:]]+[[:digit:]_]*) ]] ; then
      STACK+=( "${WORD_TEXT//_}"  1 )
   else
      STACK+=( "${WORD_TEXT}"  0 )
   fi
}

word_new  NUMBER  code_NUMBER


function code_FIND {
   WORD="$HEAD"

   while [[ "$WORD" ]] ; do
      local -n word_r="$WORD"
      if [[ "${word_r[_NAME]}" == "$WORD_TEXT" ]] ; then
         return 0
      else
         WORD="$word_r"  # 0th element is var name of next word in linked list
      fi
   done
   return 1
}

word_new  FIND  code_FIND


function code_INTERPRET {
   while [[ ! "${WORD_TEXT,,}" == 'exit' ]] ; do
      IFS= read -erp '> ' LINE
      str_read "$LINE"
      code_WORD

      code_FIND || code_NUMBER
   done
}


word_new  INTERPRET  code_NUMBER
for n in {0..2000} ; do
   word_new  INTERPRET  code_INTERPRET
done


WORD_TEXT='NUMBER'
time {
   for n in {0..60} ; do
      code_FIND
   done
}


#word_new  INTERPRET  code_INTERPRET
#code_INTERPRET
